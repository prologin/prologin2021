// SPDX-License-Identifier: GPL-2.0-or-later
// Copyright (c) 2021 Association Prologin <association@prologin.org>

// This file contains the code to call the API functions from the Python
// language.
// This file was generated by stechec2-generator. DO NOT EDIT.

#include <Python.h>
#include <vector>
#include <string>

static PyObject* py_module;
static PyObject* champ_module;


/// Types de cases
typedef enum case_type
{
    LIBRE, ///< Case libre
    OBSTACLE, ///< Obstacle
    PONT, ///< Pont
    BEBE, ///< Bébé panda
} case_type;

/// Directions cardinales
typedef enum direction
{
    NORD_EST, ///< Direction : nord-est
    SUD_EST, ///< Direction : sud-est
    SUD, ///< Direction : sud
    SUD_OUEST, ///< Direction : sud-ouest
    NORD_OUEST, ///< Direction : nord-ouest
    NORD, ///< Direction : nord
} direction;

/// Erreurs possibles
typedef enum erreur
{
    OK, ///< L'action s'est effectuée avec succès.
    POSITION_INVALIDE, ///< La position spécifiée n'est pas sur la rivière.
    POSITION_OBSTACLE, ///< La position spécifiée est un obstacle.
    MAUVAIS_NOMBRE, ///< La hauteur de la position spécifiée ne correspond pas.
    DEPLACEMENT_HORS_LIMITES, ///< Ce déplacement fait sortir un panda des limites de la rivière.
    DIRECTION_INVALIDE, ///< La direction spécifiée n'existe pas.
    MOUVEMENT_INVALIDE, ///< Le panda ne peut pas se déplacer dans cette direction.
    POSE_INVALIDE, ///< Le pont ne peut pas être placé a cette position et dans cette direction.
    ID_PANDA_INVALIDE, ///< Le panda spécifié n'existe pas.
    ACTION_DEJA_EFFECTUEE, ///< Une action a déjà été effectuée ce tour.
    RIEN_A_POUSSER, ///< Aucun panda à pousser dans la direction indiquée.
    DRAPEAU_INVALIDE, ///< Le drapeau spécifié n'existe pas.
} erreur;

/// Types d'actions
typedef enum action_type
{
    ACTION_DEPLACER, ///< Action ``deplacer``.
    ACTION_POSER, ///< Action ``poser``.
} action_type;

/// Position du panda.
typedef struct position
{
    int x; ///< Coordonnée : x
    int y; ///< Coordonnée : y
} position;

/// Case type pont, contient la case de début et de fin. La case de début a une
/// valeur se décrémentant, celle de fin s'incrémente.
typedef struct pont_type
{
    position debut_pos; ///< Position de la case de début
    position fin_pos; ///< Position de la case de fin
    int debut_val; ///< Valeur de la case de début
    int fin_val; ///< Valeur de la case de début
} pont_type;

/// Panda et son joueur
typedef struct panda_info
{
    position panda_pos; ///< Position du panda
    int id_joueur; ///< Identifiant du joueur qui contrôle le panda
    int num_bebes; ///< Nombre de bébés qui sont portés par le panda parent
} panda_info;

/// Bébé panda à ramener.
typedef struct bebe_info
{
    position bebe_pos; ///< Position du bébé panda
    int id_bebe_joueur; ///< Identifiant du joueur qui peut saver le bébé
    int points_capture; ///< Nombre de points obtenus pour la capture de ce panda
} bebe_info;

/// Information sur un tour particulier.
typedef struct tour_info
{
    int id_joueur_joue; ///< Identifiant du joueur qui joue
    int id_panda_joue; ///< Identifiant du panda qui joue
    int id_tour; ///< Identifiant unique du tour (compteur)
} tour_info;

/// Information sur la carte de la partie en cours.
typedef struct carte_info
{
    int taille_x; ///< La taille de la carte pour les coordonnées x [0; taille_x[
    int taille_y; ///< La taille de la carte pour les coordonnées y [0; taille_y[
} carte_info;

/// Action représentée dans l'historique.
typedef struct action_hist
{
    action_type type_action; ///< Type de l'action
    int id_panda; ///< Identifiant du panda concerné par l'action
    direction dir; ///< Direction visée par le panda durant le déplacement
    int valeur_debut; ///< Valeur au début du pont posé (de 1 à 6 inclus)
    int valeur_fin; ///< Valeur à la fin du pont posé (de 1 à 6 inclus)
    position pos_debut; ///< Position du début du pont posé
    position pos_fin; ///< Position de la fin du pont posé
} action_hist;

extern "C" {

/// Déplace le panda ``id_panda`` sur le pont choisi.
erreur api_deplacer(direction dir);

/// Pose un pont dans la direction choisie à partir du panda ``id_panda``.
erreur api_poser(position position_debut, direction dir, int pont_debut, int pont_fin);

/// Renvoie le type d'une case donnée.
case_type api_type_case(position pos);

/// Renvoie le numéro du joueur à qui appartient panda sur la case indiquée.
/// Renvoie -1 s'il n'y a pas de panda ou si la position est invalide.
int api_panda_sur_case(position pos);

/// Renvoie le numéro du joueur à qui appartient le bébé panda sur la case
/// indiquée. Renvoie -1 s'il n'y a pas de bébé panda ou si la position est
/// invalide.
int api_bebe_panda_sur_case(position pos);

/// Indique la position du panda sur la rivière désigné par le numéro
/// ``id_panda`` appartenant au joueur ``id_joueur``. Si la description du
/// panda est incorrecte, la position (-1, -1) est renvoyée.
position api_position_panda(int id_joueur, int id_panda);

/// Renvoie les informations relatives au pont situé à cette position. Le pont
/// est constitué de deux cases. Si aucun pont n'est placé à cette position ou
/// si la position est invalide, les membres debut_val et fin_val de la
/// structure ``pont_type`` renvoyée sont initialisés à -1.
pont_type api_info_pont(position pos);

/// Renvoie la description d'un panda en fonction d'une position donnée. Si le
/// panda n'est pas présent sur la carte, ou si la position est invalide, tous
/// les membres de la structure ``panda_info`` renvoyée sont initialisés à -1.
panda_info api_info_panda(position pos);

/// Renvoie la liste de tous les pandas présents durant la partie.
std::vector<panda_info> api_liste_pandas();

/// Renvoie la liste de tous les bébés présents sur la carte, et et pas encore
/// sauvés.
std::vector<bebe_info> api_liste_bebes();

/// Renvoie la liste de toutes les positions adjacentes à la position donnée.
std::vector<position> api_positions_adjacentes(position pos);

/// Renvoie la position relative à la direction donnée par rapport à une
/// position d'origine. Si une telle position serait invalide, la position {-1,
/// -1} est renvoyée.
position api_position_dans_direction(position pos, direction dir);

/// Renvoie la direction telle que position_dans_direction(origine, cible) ==
/// direction. Si aucune telle direction n'existe, -1 est renvoyée.
int api_direction_entre_positions(position origine, position cible);

/// Renvoie la liste des actions effectuées par l’adversaire durant son tour,
/// dans l'ordre chronologique. Les actions de débug n'apparaissent pas dans
/// cette liste.
std::vector<action_hist> api_historique();

/// Renvoie le score du joueur ``id_joueur``. Renvoie -1 si le joueur est
/// invalide.
int api_score(int id_joueur);

/// Renvoie votre numéro de joueur.
int api_moi();

/// Renvoie le numéro de joueur de votre adversaire.
int api_adversaire();

/// Renvoie le tour actuel.
tour_info api_info_tour();

/// Renvoie la carte pour la partie en cours.
carte_info api_info_carte();

/// Affiche le contenu d'une valeur de type case_type
void api_afficher_case_type(case_type v);

/// Affiche le contenu d'une valeur de type direction
void api_afficher_direction(direction v);

/// Affiche le contenu d'une valeur de type erreur
void api_afficher_erreur(erreur v);

/// Affiche le contenu d'une valeur de type action_type
void api_afficher_action_type(action_type v);

/// Affiche le contenu d'une valeur de type position
void api_afficher_position(position v);

/// Affiche le contenu d'une valeur de type pont_type
void api_afficher_pont_type(pont_type v);

/// Affiche le contenu d'une valeur de type panda_info
void api_afficher_panda_info(panda_info v);

/// Affiche le contenu d'une valeur de type bebe_info
void api_afficher_bebe_info(bebe_info v);

/// Affiche le contenu d'une valeur de type tour_info
void api_afficher_tour_info(tour_info v);

/// Affiche le contenu d'une valeur de type carte_info
void api_afficher_carte_info(carte_info v);

/// Affiche le contenu d'une valeur de type action_hist
void api_afficher_action_hist(action_hist v);
}

template <typename PythonType, typename CxxType>
PythonType cxx_to_python(CxxType in)
{
    return in.__if_that_triggers_an_error_there_is_a_problem;
}

template <>
PyObject* cxx_to_python<PyObject*, int>(int in)
{
    return PyLong_FromLong(in);
}


template <>
PyObject* cxx_to_python<PyObject*, double>(double in)
{
    return PyFloat_FromDouble(in);
}


template <>
PyObject* cxx_to_python<PyObject*, std::string>(std::string in)
{
    return PyUnicode_FromString(in.c_str());
}


template <>
PyObject* cxx_to_python<PyObject*, bool>(bool in)
{
    return PyBool_FromLong(in);
}

template <typename CxxType>
PyObject* cxx_to_python_array(const std::vector<CxxType>& in)
{
    size_t size = in.size();
    PyObject* out = PyList_New(size);

    for (unsigned int i = 0; i < size; ++i)
        PyList_SET_ITEM(out, i, (cxx_to_python<PyObject*, CxxType>(in[i])));

    return out;
}

template <typename PythonType, typename CxxType>
CxxType python_to_cxx(PythonType in)
{
    return in.__if_that_triggers_an_error_there_is_a_problem;
}

template <>
int python_to_cxx<PyObject*, int>(PyObject* in)
{
    long out = PyLong_AsLong(in);
    if (PyErr_Occurred())
        throw 42;
    return out;
}

template <>
double python_to_cxx<PyObject*, double>(PyObject* in)
{
    double out = PyFloat_AsDouble(in);
    if (PyErr_Occurred())
        throw 42;
    return out;
}

template <>
bool python_to_cxx<PyObject*, bool>(PyObject* in)
{
    return static_cast<bool>(python_to_cxx<PyObject*, int>(in));
}

template <>
std::string python_to_cxx<PyObject*, std::string>(PyObject* in)
{
    const char* out = PyUnicode_AsUTF8(in);
    if (PyErr_Occurred())
        throw 42;
    return out;
}

template <typename CxxType>
std::vector<CxxType> python_to_cxx_array(PyObject* in)
{
    if (!PyList_Check(in))
    {
        PyErr_SetString(PyExc_TypeError, "a list is required");
        throw 42;
    }

    std::vector<CxxType> out;
    unsigned int size = PyList_Size(in);
    out.reserve(size);

    for (unsigned int i = 0; i < size; ++i)
        out.push_back(python_to_cxx<PyObject*, CxxType>(PyList_GET_ITEM(in, i)));

    return out;
}

// Types de cases

template<>
PyObject* cxx_to_python<PyObject*, case_type>(case_type in)
{
    PyObject* name = PyUnicode_FromString("case_type");
    PyObject* enm = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (enm == nullptr)
        throw 42;
    PyObject* arglist = Py_BuildValue("(i)", static_cast<int>(in));
    PyObject* ret = PyObject_CallObject(enm, arglist);
    Py_DECREF(enm);
    Py_DECREF(arglist);
    return ret;
}

template <>
case_type python_to_cxx<PyObject*, case_type>(PyObject* in)
{
    return static_cast<case_type>(python_to_cxx<PyObject*, int>(in));
}

// Directions cardinales

template<>
PyObject* cxx_to_python<PyObject*, direction>(direction in)
{
    PyObject* name = PyUnicode_FromString("direction");
    PyObject* enm = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (enm == nullptr)
        throw 42;
    PyObject* arglist = Py_BuildValue("(i)", static_cast<int>(in));
    PyObject* ret = PyObject_CallObject(enm, arglist);
    Py_DECREF(enm);
    Py_DECREF(arglist);
    return ret;
}

template <>
direction python_to_cxx<PyObject*, direction>(PyObject* in)
{
    return static_cast<direction>(python_to_cxx<PyObject*, int>(in));
}

// Erreurs possibles

template<>
PyObject* cxx_to_python<PyObject*, erreur>(erreur in)
{
    PyObject* name = PyUnicode_FromString("erreur");
    PyObject* enm = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (enm == nullptr)
        throw 42;
    PyObject* arglist = Py_BuildValue("(i)", static_cast<int>(in));
    PyObject* ret = PyObject_CallObject(enm, arglist);
    Py_DECREF(enm);
    Py_DECREF(arglist);
    return ret;
}

template <>
erreur python_to_cxx<PyObject*, erreur>(PyObject* in)
{
    return static_cast<erreur>(python_to_cxx<PyObject*, int>(in));
}

// Types d'actions

template<>
PyObject* cxx_to_python<PyObject*, action_type>(action_type in)
{
    PyObject* name = PyUnicode_FromString("action_type");
    PyObject* enm = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (enm == nullptr)
        throw 42;
    PyObject* arglist = Py_BuildValue("(i)", static_cast<int>(in));
    PyObject* ret = PyObject_CallObject(enm, arglist);
    Py_DECREF(enm);
    Py_DECREF(arglist);
    return ret;
}

template <>
action_type python_to_cxx<PyObject*, action_type>(PyObject* in)
{
    return static_cast<action_type>(python_to_cxx<PyObject*, int>(in));
}

// Position du panda.

template <>
PyObject* cxx_to_python<PyObject*, position>(position in)
{
    PyObject* tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(tuple, 0, (cxx_to_python<PyObject*, int>(in.x)));
    PyTuple_SET_ITEM(tuple, 1, (cxx_to_python<PyObject*, int>(in.y)));
    return tuple;
}

template <>
position python_to_cxx<PyObject*, position>(PyObject* in)
{
    position out;
    PyObject* i;

    // Coordonnée : x
    i = PyTuple_GetItem(in, 0);
    if (i == nullptr)
        throw 42;
    out.x = python_to_cxx<PyObject*, int>(i);

    // Coordonnée : y
    i = PyTuple_GetItem(in, 1);
    if (i == nullptr)
        throw 42;
    out.y = python_to_cxx<PyObject*, int>(i);

    return out;
}

// Case type pont, contient la case de début et de fin. La case de début a une
// valeur se décrémentant, celle de fin s'incrémente.

template <>
PyObject* cxx_to_python<PyObject*, pont_type>(pont_type in)
{
    PyObject* tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(tuple, 0, (cxx_to_python<PyObject*, position>(in.debut_pos)));
    PyTuple_SET_ITEM(tuple, 1, (cxx_to_python<PyObject*, position>(in.fin_pos)));
    PyTuple_SET_ITEM(tuple, 2, (cxx_to_python<PyObject*, int>(in.debut_val)));
    PyTuple_SET_ITEM(tuple, 3, (cxx_to_python<PyObject*, int>(in.fin_val)));
    PyObject* name = PyUnicode_FromString("pont_type");
    PyObject* cstr = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (cstr == nullptr)
        throw 42;
    PyObject* ret = PyObject_CallObject(cstr, tuple);
    Py_DECREF(cstr);
    Py_DECREF(tuple);
    if (ret == nullptr)
        throw 42;
    return ret;
}

template <>
pont_type python_to_cxx<PyObject*, pont_type>(PyObject* in)
{
    pont_type out;
    PyObject* i;

    // Position de la case de début
    i = cxx_to_python<PyObject*, int>(0);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.debut_pos = python_to_cxx<PyObject*, position>(i);
    Py_DECREF(i);

    // Position de la case de fin
    i = cxx_to_python<PyObject*, int>(1);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.fin_pos = python_to_cxx<PyObject*, position>(i);
    Py_DECREF(i);

    // Valeur de la case de début
    i = cxx_to_python<PyObject*, int>(2);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.debut_val = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    // Valeur de la case de début
    i = cxx_to_python<PyObject*, int>(3);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.fin_val = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    return out;
}

// Panda et son joueur

template <>
PyObject* cxx_to_python<PyObject*, panda_info>(panda_info in)
{
    PyObject* tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(tuple, 0, (cxx_to_python<PyObject*, position>(in.panda_pos)));
    PyTuple_SET_ITEM(tuple, 1, (cxx_to_python<PyObject*, int>(in.id_joueur)));
    PyTuple_SET_ITEM(tuple, 2, (cxx_to_python<PyObject*, int>(in.num_bebes)));
    PyObject* name = PyUnicode_FromString("panda_info");
    PyObject* cstr = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (cstr == nullptr)
        throw 42;
    PyObject* ret = PyObject_CallObject(cstr, tuple);
    Py_DECREF(cstr);
    Py_DECREF(tuple);
    if (ret == nullptr)
        throw 42;
    return ret;
}

template <>
panda_info python_to_cxx<PyObject*, panda_info>(PyObject* in)
{
    panda_info out;
    PyObject* i;

    // Position du panda
    i = cxx_to_python<PyObject*, int>(0);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.panda_pos = python_to_cxx<PyObject*, position>(i);
    Py_DECREF(i);

    // Identifiant du joueur qui contrôle le panda
    i = cxx_to_python<PyObject*, int>(1);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.id_joueur = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    // Nombre de bébés qui sont portés par le panda parent
    i = cxx_to_python<PyObject*, int>(2);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.num_bebes = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    return out;
}

// Bébé panda à ramener.

template <>
PyObject* cxx_to_python<PyObject*, bebe_info>(bebe_info in)
{
    PyObject* tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(tuple, 0, (cxx_to_python<PyObject*, position>(in.bebe_pos)));
    PyTuple_SET_ITEM(tuple, 1, (cxx_to_python<PyObject*, int>(in.id_bebe_joueur)));
    PyTuple_SET_ITEM(tuple, 2, (cxx_to_python<PyObject*, int>(in.points_capture)));
    PyObject* name = PyUnicode_FromString("bebe_info");
    PyObject* cstr = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (cstr == nullptr)
        throw 42;
    PyObject* ret = PyObject_CallObject(cstr, tuple);
    Py_DECREF(cstr);
    Py_DECREF(tuple);
    if (ret == nullptr)
        throw 42;
    return ret;
}

template <>
bebe_info python_to_cxx<PyObject*, bebe_info>(PyObject* in)
{
    bebe_info out;
    PyObject* i;

    // Position du bébé panda
    i = cxx_to_python<PyObject*, int>(0);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.bebe_pos = python_to_cxx<PyObject*, position>(i);
    Py_DECREF(i);

    // Identifiant du joueur qui peut saver le bébé
    i = cxx_to_python<PyObject*, int>(1);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.id_bebe_joueur = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    // Nombre de points obtenus pour la capture de ce panda
    i = cxx_to_python<PyObject*, int>(2);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.points_capture = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    return out;
}

// Information sur un tour particulier.

template <>
PyObject* cxx_to_python<PyObject*, tour_info>(tour_info in)
{
    PyObject* tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(tuple, 0, (cxx_to_python<PyObject*, int>(in.id_joueur_joue)));
    PyTuple_SET_ITEM(tuple, 1, (cxx_to_python<PyObject*, int>(in.id_panda_joue)));
    PyTuple_SET_ITEM(tuple, 2, (cxx_to_python<PyObject*, int>(in.id_tour)));
    PyObject* name = PyUnicode_FromString("tour_info");
    PyObject* cstr = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (cstr == nullptr)
        throw 42;
    PyObject* ret = PyObject_CallObject(cstr, tuple);
    Py_DECREF(cstr);
    Py_DECREF(tuple);
    if (ret == nullptr)
        throw 42;
    return ret;
}

template <>
tour_info python_to_cxx<PyObject*, tour_info>(PyObject* in)
{
    tour_info out;
    PyObject* i;

    // Identifiant du joueur qui joue
    i = cxx_to_python<PyObject*, int>(0);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.id_joueur_joue = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    // Identifiant du panda qui joue
    i = cxx_to_python<PyObject*, int>(1);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.id_panda_joue = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    // Identifiant unique du tour (compteur)
    i = cxx_to_python<PyObject*, int>(2);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.id_tour = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    return out;
}

// Information sur la carte de la partie en cours.

template <>
PyObject* cxx_to_python<PyObject*, carte_info>(carte_info in)
{
    PyObject* tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(tuple, 0, (cxx_to_python<PyObject*, int>(in.taille_x)));
    PyTuple_SET_ITEM(tuple, 1, (cxx_to_python<PyObject*, int>(in.taille_y)));
    PyObject* name = PyUnicode_FromString("carte_info");
    PyObject* cstr = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (cstr == nullptr)
        throw 42;
    PyObject* ret = PyObject_CallObject(cstr, tuple);
    Py_DECREF(cstr);
    Py_DECREF(tuple);
    if (ret == nullptr)
        throw 42;
    return ret;
}

template <>
carte_info python_to_cxx<PyObject*, carte_info>(PyObject* in)
{
    carte_info out;
    PyObject* i;

    // La taille de la carte pour les coordonnées x [0; taille_x[
    i = cxx_to_python<PyObject*, int>(0);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.taille_x = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    // La taille de la carte pour les coordonnées y [0; taille_y[
    i = cxx_to_python<PyObject*, int>(1);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.taille_y = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    return out;
}

// Action représentée dans l'historique.

template <>
PyObject* cxx_to_python<PyObject*, action_hist>(action_hist in)
{
    PyObject* tuple = PyTuple_New(7);
    PyTuple_SET_ITEM(tuple, 0, (cxx_to_python<PyObject*, action_type>(in.type_action)));
    PyTuple_SET_ITEM(tuple, 1, (cxx_to_python<PyObject*, int>(in.id_panda)));
    PyTuple_SET_ITEM(tuple, 2, (cxx_to_python<PyObject*, direction>(in.dir)));
    PyTuple_SET_ITEM(tuple, 3, (cxx_to_python<PyObject*, int>(in.valeur_debut)));
    PyTuple_SET_ITEM(tuple, 4, (cxx_to_python<PyObject*, int>(in.valeur_fin)));
    PyTuple_SET_ITEM(tuple, 5, (cxx_to_python<PyObject*, position>(in.pos_debut)));
    PyTuple_SET_ITEM(tuple, 6, (cxx_to_python<PyObject*, position>(in.pos_fin)));
    PyObject* name = PyUnicode_FromString("action_hist");
    PyObject* cstr = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (cstr == nullptr)
        throw 42;
    PyObject* ret = PyObject_CallObject(cstr, tuple);
    Py_DECREF(cstr);
    Py_DECREF(tuple);
    if (ret == nullptr)
        throw 42;
    return ret;
}

template <>
action_hist python_to_cxx<PyObject*, action_hist>(PyObject* in)
{
    action_hist out;
    PyObject* i;

    // Type de l'action
    i = cxx_to_python<PyObject*, int>(0);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.type_action = python_to_cxx<PyObject*, action_type>(i);
    Py_DECREF(i);

    // Identifiant du panda concerné par l'action
    i = cxx_to_python<PyObject*, int>(1);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.id_panda = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    // Direction visée par le panda durant le déplacement
    i = cxx_to_python<PyObject*, int>(2);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.dir = python_to_cxx<PyObject*, direction>(i);
    Py_DECREF(i);

    // Valeur au début du pont posé (de 1 à 6 inclus)
    i = cxx_to_python<PyObject*, int>(3);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.valeur_debut = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    // Valeur à la fin du pont posé (de 1 à 6 inclus)
    i = cxx_to_python<PyObject*, int>(4);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.valeur_fin = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    // Position du début du pont posé
    i = cxx_to_python<PyObject*, int>(5);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.pos_debut = python_to_cxx<PyObject*, position>(i);
    Py_DECREF(i);

    // Position de la fin du pont posé
    i = cxx_to_python<PyObject*, int>(6);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.pos_fin = python_to_cxx<PyObject*, position>(i);
    Py_DECREF(i);

    return out;
}


// Python native wrapper for function deplacer.
// Déplace le panda ``id_panda`` sur le pont choisi.
static PyObject* p_deplacer(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_dir;
    if (!PyArg_ParseTuple(args, "O", &arg_dir))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, erreur>(api_deplacer(python_to_cxx<PyObject*, direction>(arg_dir)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function poser.
// Pose un pont dans la direction choisie à partir du panda ``id_panda``.
static PyObject* p_poser(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_position_debut;
    PyObject* arg_dir;
    PyObject* arg_pont_debut;
    PyObject* arg_pont_fin;
    if (!PyArg_ParseTuple(args, "OOOO", &arg_position_debut, &arg_dir, &arg_pont_debut, &arg_pont_fin))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, erreur>(api_poser(python_to_cxx<PyObject*, position>(arg_position_debut), python_to_cxx<PyObject*, direction>(arg_dir), python_to_cxx<PyObject*, int>(arg_pont_debut), python_to_cxx<PyObject*, int>(arg_pont_fin)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function type_case.
// Renvoie le type d'une case donnée.
static PyObject* p_type_case(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "O", &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, case_type>(api_type_case(python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function panda_sur_case.
// Renvoie le numéro du joueur à qui appartient panda sur la case indiquée.
// Renvoie -1 s'il n'y a pas de panda ou si la position est invalide.
static PyObject* p_panda_sur_case(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "O", &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_panda_sur_case(python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function bebe_panda_sur_case.
// Renvoie le numéro du joueur à qui appartient le bébé panda sur la case
// indiquée. Renvoie -1 s'il n'y a pas de bébé panda ou si la position est
// invalide.
static PyObject* p_bebe_panda_sur_case(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "O", &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_bebe_panda_sur_case(python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function position_panda.
// Indique la position du panda sur la rivière désigné par le numéro
// ``id_panda`` appartenant au joueur ``id_joueur``. Si la description du panda
// est incorrecte, la position (-1, -1) est renvoyée.
static PyObject* p_position_panda(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_id_joueur;
    PyObject* arg_id_panda;
    if (!PyArg_ParseTuple(args, "OO", &arg_id_joueur, &arg_id_panda))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, position>(api_position_panda(python_to_cxx<PyObject*, int>(arg_id_joueur), python_to_cxx<PyObject*, int>(arg_id_panda)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function info_pont.
// Renvoie les informations relatives au pont situé à cette position. Le pont
// est constitué de deux cases. Si aucun pont n'est placé à cette position ou
// si la position est invalide, les membres debut_val et fin_val de la
// structure ``pont_type`` renvoyée sont initialisés à -1.
static PyObject* p_info_pont(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "O", &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, pont_type>(api_info_pont(python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function info_panda.
// Renvoie la description d'un panda en fonction d'une position donnée. Si le
// panda n'est pas présent sur la carte, ou si la position est invalide, tous
// les membres de la structure ``panda_info`` renvoyée sont initialisés à -1.
static PyObject* p_info_panda(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "O", &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, panda_info>(api_info_panda(python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function liste_pandas.
// Renvoie la liste de tous les pandas présents durant la partie.
static PyObject* p_liste_pandas(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_liste_pandas());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function liste_bebes.
// Renvoie la liste de tous les bébés présents sur la carte, et et pas encore
// sauvés.
static PyObject* p_liste_bebes(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_liste_bebes());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function positions_adjacentes.
// Renvoie la liste de toutes les positions adjacentes à la position donnée.
static PyObject* p_positions_adjacentes(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "O", &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_positions_adjacentes(python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function position_dans_direction.
// Renvoie la position relative à la direction donnée par rapport à une
// position d'origine. Si une telle position serait invalide, la position {-1,
// -1} est renvoyée.
static PyObject* p_position_dans_direction(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    PyObject* arg_dir;
    if (!PyArg_ParseTuple(args, "OO", &arg_pos, &arg_dir))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, position>(api_position_dans_direction(python_to_cxx<PyObject*, position>(arg_pos), python_to_cxx<PyObject*, direction>(arg_dir)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function direction_entre_positions.
// Renvoie la direction telle que position_dans_direction(origine, cible) ==
// direction. Si aucune telle direction n'existe, -1 est renvoyée.
static PyObject* p_direction_entre_positions(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_origine;
    PyObject* arg_cible;
    if (!PyArg_ParseTuple(args, "OO", &arg_origine, &arg_cible))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_direction_entre_positions(python_to_cxx<PyObject*, position>(arg_origine), python_to_cxx<PyObject*, position>(arg_cible)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function historique.
// Renvoie la liste des actions effectuées par l’adversaire durant son tour,
// dans l'ordre chronologique. Les actions de débug n'apparaissent pas dans
// cette liste.
static PyObject* p_historique(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_historique());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function score.
// Renvoie le score du joueur ``id_joueur``. Renvoie -1 si le joueur est
// invalide.
static PyObject* p_score(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_id_joueur;
    if (!PyArg_ParseTuple(args, "O", &arg_id_joueur))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_score(python_to_cxx<PyObject*, int>(arg_id_joueur)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function moi.
// Renvoie votre numéro de joueur.
static PyObject* p_moi(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_moi());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function adversaire.
// Renvoie le numéro de joueur de votre adversaire.
static PyObject* p_adversaire(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_adversaire());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function info_tour.
// Renvoie le tour actuel.
static PyObject* p_info_tour(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, tour_info>(api_info_tour());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function info_carte.
// Renvoie la carte pour la partie en cours.
static PyObject* p_info_carte(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, carte_info>(api_info_carte());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_case_type.
// Affiche le contenu d'une valeur de type case_type
static PyObject* p_afficher_case_type(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_case_type(python_to_cxx<PyObject*, case_type>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_direction.
// Affiche le contenu d'une valeur de type direction
static PyObject* p_afficher_direction(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_direction(python_to_cxx<PyObject*, direction>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_erreur.
// Affiche le contenu d'une valeur de type erreur
static PyObject* p_afficher_erreur(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_erreur(python_to_cxx<PyObject*, erreur>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_action_type.
// Affiche le contenu d'une valeur de type action_type
static PyObject* p_afficher_action_type(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_action_type(python_to_cxx<PyObject*, action_type>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_position.
// Affiche le contenu d'une valeur de type position
static PyObject* p_afficher_position(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_position(python_to_cxx<PyObject*, position>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_pont_type.
// Affiche le contenu d'une valeur de type pont_type
static PyObject* p_afficher_pont_type(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_pont_type(python_to_cxx<PyObject*, pont_type>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_panda_info.
// Affiche le contenu d'une valeur de type panda_info
static PyObject* p_afficher_panda_info(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_panda_info(python_to_cxx<PyObject*, panda_info>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_bebe_info.
// Affiche le contenu d'une valeur de type bebe_info
static PyObject* p_afficher_bebe_info(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_bebe_info(python_to_cxx<PyObject*, bebe_info>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_tour_info.
// Affiche le contenu d'une valeur de type tour_info
static PyObject* p_afficher_tour_info(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_tour_info(python_to_cxx<PyObject*, tour_info>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_carte_info.
// Affiche le contenu d'une valeur de type carte_info
static PyObject* p_afficher_carte_info(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_carte_info(python_to_cxx<PyObject*, carte_info>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_action_hist.
// Affiche le contenu d'une valeur de type action_hist
static PyObject* p_afficher_action_hist(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_action_hist(python_to_cxx<PyObject*, action_hist>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// API function to register.
static PyMethodDef api_callback[] = {
    {"deplacer", p_deplacer, METH_VARARGS, "deplacer"},
    {"poser", p_poser, METH_VARARGS, "poser"},
    {"type_case", p_type_case, METH_VARARGS, "type_case"},
    {"panda_sur_case", p_panda_sur_case, METH_VARARGS, "panda_sur_case"},
    {"bebe_panda_sur_case", p_bebe_panda_sur_case, METH_VARARGS, "bebe_panda_sur_case"},
    {"position_panda", p_position_panda, METH_VARARGS, "position_panda"},
    {"info_pont", p_info_pont, METH_VARARGS, "info_pont"},
    {"info_panda", p_info_panda, METH_VARARGS, "info_panda"},
    {"liste_pandas", p_liste_pandas, METH_VARARGS, "liste_pandas"},
    {"liste_bebes", p_liste_bebes, METH_VARARGS, "liste_bebes"},
    {"positions_adjacentes", p_positions_adjacentes, METH_VARARGS, "positions_adjacentes"},
    {"position_dans_direction", p_position_dans_direction, METH_VARARGS, "position_dans_direction"},
    {"direction_entre_positions", p_direction_entre_positions, METH_VARARGS, "direction_entre_positions"},
    {"historique", p_historique, METH_VARARGS, "historique"},
    {"score", p_score, METH_VARARGS, "score"},
    {"moi", p_moi, METH_VARARGS, "moi"},
    {"adversaire", p_adversaire, METH_VARARGS, "adversaire"},
    {"info_tour", p_info_tour, METH_VARARGS, "info_tour"},
    {"info_carte", p_info_carte, METH_VARARGS, "info_carte"},
    {"afficher_case_type", p_afficher_case_type, METH_VARARGS, "afficher_case_type"},
    {"afficher_direction", p_afficher_direction, METH_VARARGS, "afficher_direction"},
    {"afficher_erreur", p_afficher_erreur, METH_VARARGS, "afficher_erreur"},
    {"afficher_action_type", p_afficher_action_type, METH_VARARGS, "afficher_action_type"},
    {"afficher_position", p_afficher_position, METH_VARARGS, "afficher_position"},
    {"afficher_pont_type", p_afficher_pont_type, METH_VARARGS, "afficher_pont_type"},
    {"afficher_panda_info", p_afficher_panda_info, METH_VARARGS, "afficher_panda_info"},
    {"afficher_bebe_info", p_afficher_bebe_info, METH_VARARGS, "afficher_bebe_info"},
    {"afficher_tour_info", p_afficher_tour_info, METH_VARARGS, "afficher_tour_info"},
    {"afficher_carte_info", p_afficher_carte_info, METH_VARARGS, "afficher_carte_info"},
    {"afficher_action_hist", p_afficher_action_hist, METH_VARARGS, "afficher_action_hist"},
    {nullptr, nullptr, 0, nullptr}
};

// Initialize C module.
PyMODINIT_FUNC PyInit__api()
{
    static struct PyModuleDef apimoduledef = {
        PyModuleDef_HEAD_INIT,
        "_api",
        "API module",
        -1,
        api_callback,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
    };
    return PyModule_Create(&apimoduledef);
}

// Load a Python module.
static PyObject* _import_module(const char* m)
{
    PyObject* name = PyUnicode_FromString(m);
    PyObject* mod = PyImport_Import(name);
    Py_DECREF(name);
    if (mod == nullptr)
        if (PyErr_Occurred())
        {
            PyErr_Print();
            abort();
        }
    return mod;
}

// Initialize Python VM, register API functions, and load .py file.
static void _init_python()
{
    static wchar_t empty_string[] = L"";
    static wchar_t *argv[] = { (wchar_t *) &empty_string, nullptr };

    const char* champion_path;

    champion_path = getenv("CHAMPION_PATH");
    if (champion_path == nullptr)
        champion_path = ".";

    setenv("PYTHONPATH", champion_path, 1);

    static wchar_t program_name[] = L"stechec";
    Py_SetProgramName(program_name);

    PyImport_AppendInittab("_api", PyInit__api);
    Py_Initialize();
    PySys_SetArgvEx(1, argv, 0);

    // Import a Champion module with an uppercase letter to avoid conflict with
    // champion.so
    champ_module = _import_module("Champion");
    py_module = _import_module("api");
}

// Flush stdout and stderr
static void flush_std_files()
{
    PyObject *fout = PySys_GetObject("stdout");
    PyObject *ferr = PySys_GetObject("stderr");
    PyObject *tmp;

    if (fout != nullptr && fout != Py_None) {
        tmp = PyObject_CallMethod(fout, "flush", "");
        if (tmp == nullptr)
            PyErr_WriteUnraisable(fout);
        else
            Py_DECREF(tmp);
    }

    if (ferr != nullptr && ferr != Py_None) {
        tmp = PyObject_CallMethod(ferr, "flush", "");
        if (tmp == nullptr)
            PyErr_Clear();
        else
            Py_DECREF(tmp);
    }
}

// Run a Python function.
static PyObject* _call_python_function(const char* name)
{
    static bool initialized = false;

    if (!initialized)
    {
        initialized = true;
        _init_python();
    }

    PyObject *arglist, *func;
    PyObject *result = nullptr;

    func = PyObject_GetAttrString(champ_module, name);
    if (func && PyCallable_Check(func))
    {
        arglist = Py_BuildValue("()");
        result = PyEval_CallObject(func, arglist);
        Py_XDECREF(arglist);
        Py_DECREF(func);
    }
    if (result == nullptr && PyErr_Occurred())
    {
        PyErr_Print();
        abort();
    }

    flush_std_files();
    return result;
}


// Functions called from Stechec to Python.

extern "C" void partie_init()
{
    PyObject* _retval = _call_python_function("partie_init");
    try {
        Py_XDECREF(_retval);
    } catch (...) {
        PyErr_Print();
        abort();
    }
}

extern "C" void jouer_tour()
{
    PyObject* _retval = _call_python_function("jouer_tour");
    try {
        Py_XDECREF(_retval);
    } catch (...) {
        PyErr_Print();
        abort();
    }
}

extern "C" void partie_fin()
{
    PyObject* _retval = _call_python_function("partie_fin");
    try {
        Py_XDECREF(_retval);
    } catch (...) {
        PyErr_Print();
        abort();
    }
}
